---
title: "WaveletMatrixOverview"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{WaveletMatrixOverview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

```{r setup}
library(WaveletMatrixProject)
```

# Introduction

The `WaveletMatrixProject` is a package built for the construction and manipulation of wavelets and wavelet transformation matrices. These tools are essential for signal processing tasks, such as:

- Decomposing signals into multiple resolutions.
- Analyzing frequency components across different scales.
- Enhancing feature extraction, and reconstructing signals from wavelet transformations.

This vignette serves as a guide to the package, composing of:

- **Detailed Core-Function Descriptions**: Clear explanations of each function's purpose and role in signal processing.
- **Code Examples**: Step-by-step demonstrations to help you understand usage.
- **Visual Outputs**: Graphs and plots to illustrate the effects of transformations.

By the end of this vignette, you will be able to:

- Construct wavelets and wavelet packet matrices using the functions.
- Apply advanced transformations for multi-resolution signal analysis.
- Combine supporting utilities like filter dilation and vector embedding to enhance workflow.

#Core Functions

## 1. `WavmatND()`
**Description**: The WavmatND() function generates a wavelet matrix by applying a high-pass filter to an identity matrix. This then constructs a transformation matrix that captures the high-frequency details of a signal. The function is useful in non-decimated wavelet transforms where no down-sampling is performed. Therefore, it preserves the original signal length.

Key arguments:

- hf: Numeric vector representing the high-pass filter coefficients.
- N: Size of the wavelet matrix (signal length).
- k: The number of decomposition levels.
- shift: The number that indicates the shift needed to be applied to the filter at each iteration.

WavmatND() supports multi-resolution analysis by enabling signal decomposition at finer scales.

### Example
```{r WavmatND-example}
# Define parameters
hf <- c(0.5, -0.5) # High-pass filter
N <- 4  # Signal length
k <- 3  # Decomposition levels
shift <- 1  # Filter shift

# Construct the wavelet matrix
W <- WavmatND(hf, N, k, shift)
print(W)

# Visualizing the wavelet matrix
image(W, main = "Wavelet Matrix (WavmatND)", xlab = "Columns", ylab = "Rows", col = heat.colors(256))
```
**Explanation**: The WavmatND() function starts with an identity matrix and applies a high-pass filter to construct the wavelet matrix. This matrix can be used for signal processing tasks where transformations are needed to capture specific frequency components in signals.

**Suporting Functions**: 
- dilate_filter():  Dilates the filter coefficients for higher decomposition levels.
- imbed(): Embeds a vector by appending zeros.
- repeating(): Creates repeated sequences from input vectors.

For a more detailed demonstration, see WavmatND_demo1 and WavmatND_demo2 in the demo folder.


## 2. `WavPackMatWP()`
**Description**: Constructs a wavelet packet transformation matrix using a low-pass filter. This matrix represents a transformation that decomposes signals into components at different levels of detail.

Key Arguments:
- h: Numeric vector representing the low-pass filter.
- N: Integer specifying the size of the matrix (must be a power of 2).
- k0: Integer specifying the depth of the wavelet transformation.
- shift: Integer for shifts in the wavelet transformation (default is 2).

### Example
```{r WavPackMatWP-example}
# Low-pass filter
h <- c(0.5, 0.5) #Low-pass filer
N <- 8 #Signal size (must be a power of 2, 2^3 in this case)
k0 <- 2 #Depth of decomposition
shift <- 2 #Shift parameter

# Construct the wavelet packet matrix
WP <- WavPackMatWP(h, N, k0, shift)
print(WP)


# Visualizing the wavelet packet matrix
image(WP, main = "Wavelet Packet Matrix (WavPackMatWP)", xlab = "Columns", ylab = "Rows", col = heat.colors(256))
```

**Explanation**: WavPackMatWP() builds a matrix for wavelet packet transformation up to a depth k0. It uses the low-pass filter (h) to decompose the signal and create a matrix that captures different levels of detail. This function is essential for performing multi-resolution analysis.

**Supporting Functions:**
**getsubWP():** This function constructs sub-matrices for the wavelet packet transformation at each decomposition level. It iteratively applies low-pass (H) and high-pass (G) filters which generate sub-matrices that represent transformations at different decomposition levels.

**Key Components of getsubWP():**
- Iterative construction: getsubWP() builds sub-matrices by applying filters at each level in reverse order.
-Filter applications: Combines H and G matrices in order to decompose the signal at its current level. 
- Arguments in getsubWP():
  - jstep: Current decomposition level.
  - h: Low-pass filter.
  - g: Hgh-pass filter.
  - J: Maximum number of decomposition levels.
  - N: Size of signal/matrix

**getHGmatWP():** This function computes matrices using the input filters (H and G), adjusting their elements with a modulus operation to handle boundary conditions. This helps ensure that the transformation correctly wraps around indices when applying the filters.

**Key Components of getHGmatWP():**
- Arguments in getHGmatWP():
  - k: Current decomposition level.
  - h: Low-pass filter.
  - g: Hgh-pass filter.
  - J: Maximum number of decomposition levels.
  - N: Size of signal/matrix

For a more detailed demonstration, see WavmatND_demo1 and WavmatND_demo2 in the demo folder.


## 3. `WavPackMat()`
**Description**: This function constructs an optimized orthogonal wavelet transformation matrix using a low-pass filter. This matrix is used for efficient wavelet-based signal processing.

### Example
```{r WavPackMat-example}
# Low-pass filter
h <- c(0.5, 0.5)

# Parameters for wavelet transformation matrix
N <- 8 #Matrix size (2^3 in this case)
k0 <- 3 #Depth of wavelet decomposition
shift <- 2 #Shift parameter

# Construct the wavelet transformation matrix
WP_opt <- WavPackMat(h, N, k0, shift)
print(WP_opt)

# Visualize the matrix
image(WP_opt, main = "Wavelet Transformation Matrix", xlab = "Columns", ylab = "Rows", col = heat.colors(256))

```

**Explanation**: WavPackMat() uses the low-pass filter (h) to create an orthogonal matrix for efficient decomposition and reconstruction.


**Supporting Functions:**
**getsubW():** Constructs sub-matrices for the wavelet transformation at each level. It applies the H and G matrices at each iteration to create sub-matrices for each decomposition level, which is essential for building the wavelet matrix used for signal decomposition.

**Key Components of getsubW():**
- Arguments in getsubW():
  - jstep: Current decomposition level.
  - h: Low-pass filter.
  - g: Hgh-pass filter.
  - J: Maximum number of decomposition levels.
  - N: Size of matrix.

**getHGmat():** This function creates H and G matrices that are critical for constructing wavelet transformations with circular boundary conditions. The matrices ensure that the input signal is properly processed even when indices wrap around.

**Key Components of getsubW():**
Matrix Construction: Create the H and G matrices by applying the low-pass (h) and high-pass (g) filters.
Boundary Handling: Use modulus operations to wrap around indices. This ensures that the matrix respects circular boundary conditions.
- Arguments in getsubW():
  - k: Current decomposition level.
  - h: Low-pass filter.
  - g: Hgh-pass filter.
  - J: Maximum number of decomposition levels.
  - N: Size of matrix.


For a more detailed demonstration, see Wavmat_demo1 and Wavmat_demo2 in the demo folder.


## 4. Demo

For further and more in-depth exhibitions of how these functions work, please refer to the demo folder. There are various demonstrations included on how the functions help in thresholding, image-processing, and more.

