theme_minimal(base_size = 16) +
ggtitle("Wavelet Coefficients")
# (vi) Threshold the small coefficients
finest <- sw[(N/2+1):N]
sigmahat <- sd(finest)
lambda <- sqrt(2 * log(N)) * sigmahat
# Apply soft thresholding
swt <- sign(sw) * pmax(abs(sw) - lambda, 0)
swt_length <- length(swt)
# Convert and display the thresholded wavelet coefficients as an image
swt_img <- as.cimg(matrix(swt, nrow = 1, ncol = swt_length))
plot(swt_img, main = "Thresholded Wavelet Coefficients Image Representation")
# Plot the thresholded coefficients
ggplot(data.frame(index = 1:N, swt = swt), aes(x = index, y = swt)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Thresholded Wavelet Coefficients")
# (vii) Return the signal to the time domain using the inverse transformation
a <- as.vector(t(WP) %*% swt)
# (viii) Plot the denoised signal and the noisy signal for comparison
ggplot(data.frame(t = t, signoi = signoi, a = a), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = a), color = "black", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Denoised Signal")
#' Demo for Wavelet Denoising using the WaveletMatrixProject package
#'
#' This demo showcases how to denoise a synthetic "bumps" signal using a wavelet
#' packet transformation matrix constructed by WavPackMat.
#' Run this demo using: demo("wavelet_denoising", package = "WaveletMatrixProject")
# Load necessary libraries
library(WaveletMatrixProject)
# (i) Generate the "bumps" signal
N <- 1024
t <- seq(0, 1, length.out = N)
pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
wth <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
sig <- numeric(N)
for (j in 1:length(pos)) {
sig <- sig + hgt[j] / (1 + abs((t - pos[j]) / wth[j]))^4
}
# Standardize the signal for a fixed SNR
SNR <- 7
sig <- sig * sqrt(SNR) / sd(sig)
# Plot the original signal
ggplot(data.frame(t = t, sig = sig), aes(x = t, y = sig)) +
geom_line(color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Original Bumps Signal")
#' Construct Highly Optimized Orthogonal Wavelet Transformation Matrix
#'
#' This function creates an optimized wavelet transformation matrix for high-quality filter coefficients
#' and sparse matrix operations.
#'
#' @param h Numeric vector representing the low-pass filter.
#' @param N Integer specifying the size of the matrix. Must be a power of 2.
#' @param k0 Integer specifying the depth of the wavelet transformation. Should be between 1 and log2(N).
#' @param shift Integer for shifts in the wavelet transformation (default is 2).
#' @return A sparse matrix representing the wavelet packet transformation.
#' @export
#' @importFrom Matrix rBind
#' @import ggplot2
#' @import imager
#' @import pracma
WavPackMat <- function(h, N, k0, shift = 2) {
J <- log2(N)
if (J != floor(J)) {
stop("N has to be a power of 2.")
}
# Make QM filter G
# Make QM filter G
h <- as.vector(h)
g <- rev(Conj(h) * (-1)^(1:length(h)))
h <- c(h, rep(0, N - length(h)))
g <- c(g, rep(0, N - length(g)))
WP <- matrix(nrow = 0, ncol = N)
for (k in 1:k0) {
subW <- getsubW(k, h, g, J, N)
WP <- rbind(WP, subW)
}
WP <- sqrt(1/k0) * WP
return(WP)
}
getsubW <- function(jstep, h, g, J, N) {
subW <- diag(2^(J-jstep))
for (k in jstep:1) {
hgmat <- getHGmat(k, h, g, J, N)
subW <- rbind(subW %*% hgmat$hmat, subW %*% hgmat$gmat)
}
return(subW)
}
getHGmat <- function(k, h, g, J, N) {
ubJk <- 2^(J-k)
ubJk1 <- 2^(J-k+1)
shift <- 2
hmat <- matrix(0, nrow = ubJk1, ncol = ubJk)
gmat <- matrix(0, nrow = ubJk1, ncol = ubJk)
for (jj in 1:ubJk) {
for (ii in 1:ubJk1) {
modulus <- (N + ii - 2 * jj + shift) %% ubJk1
modulus <- modulus + (modulus == 0) * ubJk1
hmat[ii, jj] <- h[modulus]
gmat[ii, jj] <- g[modulus]
}
}
return(list(hmat = t(hmat), gmat = t(gmat)))
}
#' Demo for Wavelet Denoising using the WaveletMatrixProject package
#'
#' This demo showcases how to denoise a synthetic "bumps" signal using a wavelet
#' packet transformation matrix constructed by WavPackMat.
#' Run this demo using: demo("wavelet_denoising", package = "WaveletMatrixProject")
# Load necessary libraries
library(WaveletMatrixProject)
# (i) Generate the "bumps" signal
N <- 1024
t <- seq(0, 1, length.out = N)
pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
wth <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
sig <- numeric(N)
for (j in 1:length(pos)) {
sig <- sig + hgt[j] / (1 + abs((t - pos[j]) / wth[j]))^4
}
# Standardize the signal for a fixed SNR
SNR <- 7
sig <- sig * sqrt(SNR) / sd(sig)
# Plot the original signal
ggplot(data.frame(t = t, sig = sig), aes(x = t, y = sig)) +
geom_line(color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Original Bumps Signal")
getwd()
#' Demo for Wavelet Denoising using the WaveletMatrixProject package
#'
#' This demo showcases how to denoise a synthetic "bumps" signal using a wavelet
#' packet transformation matrix constructed by WavPackMat.
#' Run this demo using: demo("wavelet_denoising", package = "WaveletMatrixProject")
# Load necessary libraries
library(WaveletMatrixProject)
source("C:/Users/saraa/Desktop/WaveletMatrixProject/demo/load_demo_libraries.R")
# (i) Generate the "bumps" signal
N <- 1024
t <- seq(0, 1, length.out = N)
pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
wth <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
sig <- numeric(N)
for (j in 1:length(pos)) {
sig <- sig + hgt[j] / (1 + abs((t - pos[j]) / wth[j]))^4
}
# Standardize the signal for a fixed SNR
SNR <- 7
sig <- sig * sqrt(SNR) / sd(sig)
# Plot the original signal
ggplot(data.frame(t = t, sig = sig), aes(x = t, y = sig)) +
geom_line(color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Original Bumps Signal")
# (ii) Add noise to the signal
set.seed(1)
signoi <- sig + 1/sqrt(SNR) * rnorm(N)
# (iii) Plot the noisy signal
ggplot(data.frame(t = t, signoi = signoi, sig = sig), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = sig), color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Noisy Bumps Signal")
# (iv) Create the wavelet transformation matrix using WavPackMat
filt <- c(-0.07576571478934, -0.02963552764595,
0.49761866763246, 0.80373875180522,
0.29785779560554, -0.09921954357694,
-0.01260396726226, 0.03222310060407)
WP <- WavPackMat(filt, N, k0 = 6)
# (v) Transform the signal using the wavelet packet matrix
sw <- as.vector(WP %*% signoi)
# Plot the wavelet coefficients
ggplot(data.frame(index = 1:N, sw = sw), aes(x = index, y = sw)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Wavelet Coefficients")
# (vi) Threshold the small coefficients
finest <- sw[(N/2+1):N]
sigmahat <- sd(finest)
lambda <- sqrt(2 * log(N)) * sigmahat
# Apply soft thresholding
swt <- sign(sw) * pmax(abs(sw) - lambda, 0)
swt_length <- length(swt)
# Convert and display the thresholded wavelet coefficients as an image
swt_img <- as.cimg(matrix(swt, nrow = 1, ncol = swt_length))
plot(swt_img, main = "Thresholded Wavelet Coefficients Image Representation")
# Plot the thresholded coefficients
ggplot(data.frame(index = 1:N, swt = swt), aes(x = index, y = swt)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Thresholded Wavelet Coefficients")
# (vii) Return the signal to the time domain using the inverse transformation
a <- as.vector(t(WP) %*% swt)
# (viii) Plot the denoised signal and the noisy signal for comparison
ggplot(data.frame(t = t, signoi = signoi, a = a), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = a), color = "black", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Denoised Signal")
# Plot the original signal
ggplot(data.frame(t = t, sig = sig), aes(x = t, y = sig)) +
geom_line(color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Original Bumps Signal")
# (iii) Plot the noisy signal
ggplot(data.frame(t = t, signoi = signoi, sig = sig), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = sig), color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Noisy Bumps Signal")
# Plot the wavelet coefficients
ggplot(data.frame(index = 1:N, sw = sw), aes(x = index, y = sw)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Wavelet Coefficients")
# Plot the thresholded coefficients
ggplot(data.frame(index = 1:N, swt = swt), aes(x = index, y = swt)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Thresholded Wavelet Coefficients")
#' Demo for Wavelet Denoising using the WaveletMatrixProject package
#'
#' This demo showcases how to denoise a synthetic "bumps" signal using a wavelet
#' packet transformation matrix constructed by WavPackMat.
#' Run this demo using: demo("wavelet_denoising", package = "WaveletMatrixProject")
# Load necessary libraries
library(WaveletMatrixProject)
source("C:/Users/saraa/Desktop/WaveletMatrixProject/demo/load_demo_libraries.R")
# (i) Generate the "bumps" signal
N <- 1024
t <- seq(0, 1, length.out = N)
pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
wth <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
sig <- numeric(N)
for (j in 1:length(pos)) {
sig <- sig + hgt[j] / (1 + abs((t - pos[j]) / wth[j]))^4
}
# Standardize the signal for a fixed SNR
SNR <- 7
sig <- sig * sqrt(SNR) / sd(sig)
# Plot the original signal
ggplot(data.frame(t = t, sig = sig), aes(x = t, y = sig)) +
geom_line(color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Original Bumps Signal")
# (ii) Add noise to the signal
set.seed(1)
signoi <- sig + 1/sqrt(SNR) * rnorm(N)
# (iii) Plot the noisy signal
ggplot(data.frame(t = t, signoi = signoi, sig = sig), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = sig), color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Noisy Bumps Signal")
# (iv) Create the wavelet transformation matrix using WavPackMat
filt <- c(-0.07576571478934, -0.02963552764595,
0.49761866763246, 0.80373875180522,
0.29785779560554, -0.09921954357694,
-0.01260396726226, 0.03222310060407)
WP <- WavPackMat(filt, N, k0 = 6)
# (v) Transform the signal using the wavelet packet matrix
sw <- as.vector(WP %*% signoi)
# Plot the wavelet coefficients
ggplot(data.frame(index = 1:N, sw = sw), aes(x = index, y = sw)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Wavelet Coefficients")
# (vi) Threshold the small coefficients
finest <- sw[(N/2+1):N]
sigmahat <- sd(finest)
lambda <- sqrt(2 * log(N)) * sigmahat
# Apply soft thresholding
swt <- sign(sw) * pmax(abs(sw) - lambda, 0)
swt_length <- length(swt)
# Convert and display the thresholded wavelet coefficients as an image
swt_img <- as.cimg(matrix(swt, nrow = 1, ncol = swt_length))
plot(swt_img, main = "Thresholded Wavelet Coefficients Image Representation")
# Plot the thresholded coefficients
ggplot(data.frame(index = 1:N, swt = swt), aes(x = index, y = swt)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Thresholded Wavelet Coefficients")
# (vii) Return the signal to the time domain using the inverse transformation
a <- as.vector(t(WP) %*% swt)
# (viii) Plot the denoised signal and the noisy signal for comparison
ggplot(data.frame(t = t, signoi = signoi, a = a), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = a), color = "black", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Denoised Signal")
# Load necessary functions and data from the package
library(WaveletMatrixProject)
source("C:/Users/saraa/Desktop/WaveletMatrixProject/demo/load_demo_libraries.R")
cat("Demo6c: Lenna 2d scale-mixing forth and back\n")
# Define Symmlet 4 wavelet filter from wavelets package
h <- c(-0.075765714789341, -0.029635527645954, 0.497618667632458,
0.803738751805216, 0.297857795605542, -0.099219543576935,
-0.012603967262261, 0.032223100604071)
# Load the Lena dataset (assuming it is available as a grayscale matrix)
data("lena")
# Transform lena data to match MATLAB's transformation of image data
A_full <- 255 - t(lena)
# Extract the central 256x256 portion for transformation
center_start <- (512 - 256) / 2 + 1
center_end <- center_start + 255
A <- A_full[center_start:center_end, center_start:center_end]
# Apply padding to the 256x256 submatrix as per MATLAB code
A[, 1:4] <- 255
A[, (ncol(A)-3):ncol(A)] <- 255
A[1:4, ] <- 255
A[(nrow(A)-3):nrow(A), ] <- 255
# Display the padded and transformed 256x256 Lena image using imager
display(as.cimg(A), main = "Padded and Transformed Lena Image (256x256)")
# Plot using base R
par(mfrow = c(2, 2))
image(A, col = gray.colors(256), main = "Padded and Transformed Lena Image (256x256)", useRaster = TRUE)
# Create wavelet matrix using WavPackMat with 256x256 size
N <- 256
k0 <- 2
W <- WavPackMat(h, N, k0)
# Apply the wavelet transformation: B = W * A * W'
B <- W %*% A %*% t(W)
# Display the transformed image using imager
display(as.cimg(B), main = "Transformed Lena Image (B)", rescale = FALSE)
# Plot using base R
image(B, col = gray.colors(256), main = "Transformed Lena Image (B)", zlim = c(0, 20), useRaster = TRUE)
# Inverse transformation: C = W' * B * W
C <- t(W) %*% B %*% W
display(as.cimg(C), main = "Inverse Transformed Image (C)")
# Plot using base R
image(C, col = gray.colors(256), main = "Inverse Transformed Image (C)", useRaster = TRUE)
# Difference image: D = A - C
D <- A - C
display(as.cimg(D), main = "Difference Image (D)", rescale = FALSE)
# Check the range of values in D
cat("Min of D:", min(D), "\n")
cat("Max of D:", max(D), "\n")
# Plot D with an adjusted zlim range
image(D, col = gray.colors(256), main = "Difference Image (D)", zlim = range(D), useRaster = TRUE)
# Scale D for better visualization
D_scaled <- D * 1000
# Checking the range of D_scaled
cat("Min of D_scaled:", min(D_scaled), "\n")
cat("Max of D_scaled:", max(D_scaled), "\n")
# Display using base R
image(D_scaled, col = gray.colors(256), main = "Scaled Difference Image (D)", useRaster = TRUE)
# Normalize D_scaled for imager display
D_scaled_normalized <- (D_scaled - min(D_scaled)) / (max(D_scaled) - min(D_scaled))
display(as.cimg(D_scaled_normalized), main = "Scaled and Normalized Difference Image (D)")
# Debugging Outputs
cat("Mean of A:", mean(A), "\n")
cat("Mean of B:", mean(B), "\n")
cat("Mean of C:", mean(C), "\n")
cat("Mean of D:", mean(D), "\n")
install.packages("devtools")
library(devtools)
devtools::document()
devtools::check()
devtools::document()
devtools::check()
# Install usethis if not already installed
install.packages("usethis")
# Create a README.md file
usethis::use_readme_md()
install.packages("usethis")
devtools::document()
devtools::check()
getwd()
library(WaveletMatrixProject)
source("C:/Users/saraa/Desktop/WaveletMatrixProject/demo/load_demo_libraries.R")
# This demo script showcases the forward and inverse wavelet packet transformation applied to a Doppler signal.
nl <- 11      # J level, V_J
n <- 2^nl     # Signal length
level <- 5    # Levels of decomposition
shift <- 2    # Standard shift
filt <- c(sqrt(2)/2, sqrt(2)/2)
# Make Doppler Signal
t <- seq(0, 1, length.out = n)
y <- sqrt(t * (1 - t)) * sin((2 * pi * 1.05) / (t + 0.05))
WP <- WavPackMatWP(filt, n, level, shift)
#' Construct Wavelet Packet Transformation Matrix
#'
#' @param h Numeric vector representing the low-pass filter.
#' @param N Integer specifying the size of the matrix. Must be a power of 2.
#' @param k0 Integer specifying the depth of the wavelet transformation. Should be between 1 and log2(N).
#' @param shift Integer for shifts in the wavelet transformation (default is 2).
#' @return A matrix representing the wavelet packet transformation.
#' @export
#' @importFrom Matrix rBind
#' @import pracma
#' @import wavelets
WavPackMatWP <- function(h, N, k0, shift = 2) {
J <- log2(N)
# Make QM filter G
h <- as.vector(h) # Ensure h is a vector
g <- rev(Conj(h) * (-1)^(1:length(h)))
if (J != floor(J)) {
stop('N has to be a power of 2.')
}
h <- c(h, rep(0, N)) # Extend filter H by 0's to sample by modulus
g <- c(g, rep(0, N)) # Extend filter G by 0's to sample by modulus
# Initialize WP with the number of columns expected from subW
subW <- getsubWP(1, h, g, J, N)  # Use the first level to check dimensions
WP <- matrix(nrow = 0, ncol = ncol(subW))
for (k in 1:k0) {
subW <- getsubWP(k, h, g, J, N)
if (ncol(WP) != ncol(subW)) {
stop("Column mismatch between WP and subW during rbind operation.")
}
WP <- rbind(WP, subW)
}
WP <- sqrt(1/k0) * WP
return(WP)
}
getsubWP <- function(jstep, h, g, J, N) {
subW <- diag(2^(J-jstep))
for (k in jstep:1) {
hgmat <- getHGmatWP(k, h, g, J, N)
subW <- rbind(subW %*% hgmat$hmat, subW %*% hgmat$gmat)
}
return(subW)
}
getHGmatWP <- function(k, h, g, J, N) {
ubJk <- 2^(J-k)
ubJk1 <- 2^(J-k+1)
shift <- 2
hmat <- matrix(0, nrow = ubJk1, ncol = ubJk)
gmat <- matrix(0, nrow = ubJk1, ncol = ubJk)
for (jj in 1:ubJk) {
for (ii in 1:ubJk1) {
modulus <- (N + ii - 2 * jj + shift) %% ubJk1
modulus <- modulus + (modulus == 0) * ubJk1
hmat[ii, jj] <- h[modulus]
gmat[ii, jj] <- g[modulus]
}
}
return(list(hmat = t(hmat), gmat = t(gmat)))
}
library(WaveletMatrixProject)
source("C:/Users/saraa/Desktop/WaveletMatrixProject/demo/load_demo_libraries.R")
# This demo script showcases the forward and inverse wavelet packet transformation applied to a Doppler signal.
nl <- 11      # J level, V_J
n <- 2^nl     # Signal length
level <- 5    # Levels of decomposition
shift <- 2    # Standard shift
filt <- c(sqrt(2)/2, sqrt(2)/2)
# Make Doppler Signal
t <- seq(0, 1, length.out = n)
y <- sqrt(t * (1 - t)) * sin((2 * pi * 1.05) / (t + 0.05))
WP <- WavPackMatWP(filt, n, level, shift)
y <- matrix(y, nrow = 2048, ncol = 1)
d <- WP %*% y
# Check summary statistics
cat('Summary of d in R:\n')
cat(sprintf('Min: %f, Max: %f, Mean: %f\n', min(d), max(d), mean(d)))
a <- t(WP) %*% d
# Plotting results
par(mfrow = c(2, 2))
plot(y, type = 'l', main = "Original Signal", xlab = "Index", ylab = "Amplitude")
plot(d, type = 'l', main = "Doppler Wavelet Packet Coefficients", xlab = "Index", ylab = "Coefficient")
plot(a, type = 'l', main = "Wavelet Packet Reconstruction", xlab = "Index", ylab = "Amplitude")
plot(a - y, type = 'l', main = "Difference between Reconstruction and Original", xlab = "Index", ylab = "Difference")
install.packages("devtools")
library(devtools)
devtools::document()
rm(list = c("WavPackMatWP"))
devtools::load_all()
devtools::document()
devtools::check()
getwd()
library(WaveletMatrixProject)
source("C:/Users/saraa/Desktop/WaveletMatrixProject/demo/load_demo_libraries.R")
# WavPackWP_demo1.R
# This demo script demonstrates the construction of a wavelet packet transformation matrix
# and its application to a sample vector.
# Define the filter (e.g., SYMMLET 4)
filt <- c(-0.07576571478934, -0.02963552764595,
0.49761866763246, 0.80373875180522,
0.29785779560554, -0.09921954357694,
-0.01260396726226, 0.03222310060407)
# Print to verify
print(filt)
# Set parameters for the wavelet packet transformation matrix
N <- 8  # Size of the matrix
k0 <- 3  # Levels of decomposition
shift <- 0  # Shift parameter
# Generate the wavelet packet transformation matrix
WP <- WavPackMatWP(filt, N, k0, shift)
# Print the matrix
print(WP)
# Example of applying this to a vector y
y <- c(1, 0, -3, 2, 1, 0, 1, 2)
d <- sqrt(k0) * WP %*% y
yy <- (1 / sqrt(k0)) * t(WP) %*% d
# Print the transformed and inverse-transformed vectors
print("d vector:")
print(d)
print("yy (inverse result):")
print(yy)
trace1 <- sum(diag(WP %*% t(WP)))
trace2 <- sum(diag(t(WP) %*% WP))
cat("Trace of WP * WP':", trace1, "\n")
cat("Trace of WP' * WP:", trace2, "\n")
devtools::document()
devtools::check()
