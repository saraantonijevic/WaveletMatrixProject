noise <- rnorm(length(s), mean = 0, sd = sigma)
sn <- s + noise
var(sn)
# a noisy doppler signal
qmf <- c(1/sqrt(2), 1/sqrt(2))  # Haar wavelet
W <- WavmatND(qmf, n, k, 0)  # wavematND
# Function to create a weight matrix in R similar to MATLAB's weight(n, k)
# Function to create a weight matrix in R similar to MATLAB's weight(n, k)
weight <- function(n, k) {
size <- (k + 1) * n  # Total size for the matrix (5000 when k = 4 and n = 1000)
T <- matrix(0, nrow = size, ncol = size)  # Initialize an empty matrix
# Assign weights so that the trace of T sums up to n (1000 in this case)
for (i in 1:(k + 1)) {
start_row <- (i - 1) * n + 1
end_row <- i * n
weight_value <- 1 / (k + 1)  # Ensure the sum of the weights in each block scales correctly
T[start_row:end_row, start_row:end_row] <- diag(weight_value, n, n)
}
return(T)
}
T <- weight(n, k)
# Signal transformation
tsn <- W %*% matrix(sn, nrow = n, ncol = 1)
cat(sprintf("Variance of transformed signal: %f\n", var(tsn)))
cat(sprintf("Variance of last detail level: %f\n", var(tsn[((k - 1) * n + 1):(k * n)])))
# Extract detail levels and apply thresholding
temp <- tsn[(n + 1):length(tsn)]
threshold <- sqrt(2 * log(n) * var(tsn[(length(tsn) - n + 1):length(tsn)]))
temp[abs(temp) < threshold] <- 0
# Reconstruct the signal
rs <- t(W) %*% T %*% c(tsn[1:n], temp)
trace <- dim(T)
cat(sprintf("Trace of T: %f\n", trace))
cat(sprintf("Variance of reconstructed signal: %f\n", var(rs)))
# Create data frames for plotting
df_original <- data.frame(Index = 1:n, Signal = s)
df_noisy <- data.frame(Index = 1:n, Signal = sn)
df_denoised <- data.frame(Index = 1:n, Signal = rs)
df_error <- data.frame(Index = 1:n, Signal = rs - s)
# Plot using ggplot2
p1 <- ggplot2::ggplot(df_original, ggplot2::aes(x = Index, y = Signal)) +
ggplot2::geom_line() +
ggplot2::ggtitle('Original Doppler Signal') +
ggplot2::theme_minimal()
p2 <- ggplot2::ggplot(df_noisy, ggplot2::aes(x = Index, y = Signal)) +
ggplot2::geom_line() +
ggplot2::ggtitle('Noisy Doppler Signal') +
ggplot2::theme_minimal()
p3 <- ggplot2::ggplot(df_denoised, ggplot2::aes(x = Index, y = Signal)) +
ggplot2::geom_line() +
ggplot2::ggtitle('De-noised Doppler Signal (Hard-Thresholding)') +
ggplot2::theme_minimal()
p4 <- ggplot2::ggplot(df_error, ggplot2::aes(x = Index, y = Signal)) +
ggplot2::geom_line() +
ggplot2::ggtitle('Error') +
ggplot2::theme_minimal()
# Arrange plots in a 4x1 grid layout
gridExtra::grid.arrange(p1, p2, p3, p4, ncol = 1)
# Reconstruct the signal
rs <- t(W) %*% T %*% c(tsn[1:n], temp)
trace <- sum(diag(T))
cat(sprintf("Trace of T: %f\n", trace))
cat(sprintf("Variance of reconstructed signal: %f\n", var(rs)))
# Create data frames for plotting
df_original <- data.frame(Index = 1:n, Signal = s)
df_noisy <- data.frame(Index = 1:n, Signal = sn)
df_denoised <- data.frame(Index = 1:n, Signal = rs)
df_error <- data.frame(Index = 1:n, Signal = rs - s)
# Plot using ggplot2
p1 <- ggplot2::ggplot(df_original, ggplot2::aes(x = Index, y = Signal)) +
ggplot2::geom_line() +
ggplot2::ggtitle('Original Doppler Signal') +
ggplot2::theme_minimal()
p2 <- ggplot2::ggplot(df_noisy, ggplot2::aes(x = Index, y = Signal)) +
ggplot2::geom_line() +
ggplot2::ggtitle('Noisy Doppler Signal') +
ggplot2::theme_minimal()
p3 <- ggplot2::ggplot(df_denoised, ggplot2::aes(x = Index, y = Signal)) +
ggplot2::geom_line() +
ggplot2::ggtitle('De-noised Doppler Signal (Hard-Thresholding)') +
ggplot2::theme_minimal()
p4 <- ggplot2::ggplot(df_error, ggplot2::aes(x = Index, y = Signal)) +
ggplot2::geom_line() +
ggplot2::ggtitle('Error') +
ggplot2::theme_minimal()
# Arrange plots in a 4x1 grid layout
gridExtra::grid.arrange(p1, p2, p3, p4, ncol = 1)
install.packages("devtools")
library(devtools)
devtools::document()
devtools::document()
rm(list = c("WavmatND"))
devtools::load_all()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
rm(list = c("dilate_filter", "imbed", "repeating"))
devtools::load_all()
devtools::document()
devtools::check()
document()
devtools::check()
document()
devtools::check()
document()
devtools::check()
document()
devtools::check()
sigma <- 0.05
m <- 250  # noise level, signal size
t <- seq(1/m, 1, length.out = m)
s <- sqrt(t * (1 - t)) * sin((2 * pi * 1.05) / (t + 0.05))  # Generate a doppler signal
noise <- rnorm(m, 0, sigma)
sn <- s + noise  # a noisy doppler signal
J <- floor(log2(m))
k <- J - 1  # decomposition level
qmf <- c(1/sqrt(2), 1/sqrt(2))  # Haar wavelet
W <- WavmatND(qmf, m, k, 0)  # wavematND
weight <- function(m, k) {
size <- (k + 1) * m # Total size for the matrix (5000 when k = 4 and n = 1000)
T <- matrix(0, nrow = size, ncol = size)  # Initialize an empty matrix
# Assign weights so that the trace of T sums up to n (1000 in this case)
for (i in 1:(k + 1)) {
start_row <- (i - 1) * m + 1
end_row <- i * m
weight_value <- 1 / (k + 1)  # Ensure the sum of the weights in each block scales correctly
T[start_row:end_row, start_row:end_row] <- diag(weight_value, n, n)
}
return(T)
}
T <- weight(m, k)
sigma <- 0.05
m <- 250  # noise level, signal size
t <- seq(1/m, 1, length.out = m)
s <- sqrt(t * (1 - t)) * sin((2 * pi * 1.05) / (t + 0.05))  # Generate a doppler signal
noise <- rnorm(m, 0, sigma)
sn <- s + noise  # a noisy doppler signal
J <- floor(log2(m))
k <- J - 1  # decomposition level
qmf <- c(1/sqrt(2), 1/sqrt(2))  # Haar wavelet
W <- WavmatND(qmf, m, k, 0)  # wavematND
weight <- function(m, k) {
size <- (k + 1) * m # Total size for the matrix (5000 when k = 4 and n = 1000)
T <- matrix(0, nrow = size, ncol = size)  # Initialize an empty matrix
# Assign weights so that the trace of T sums up to n (1000 in this case)
for (i in 1:(k + 1)) {
start_row <- (i - 1) * m + 1
end_row <- i * m
weight_value <- 1 / (k + 1)  # Ensure the sum of the weights in each block scales correctly
T[start_row:end_row, start_row:end_row] <- diag(weight_value, m, m)
}
return(T)
}
T <- weight(m, k)
dim(T)
tsn=W*t(sn) #transformed signal
t(sn)
dim(t(sn))
sim(W)
dim(W)
tsn=W*sn #transformed signal
library(WaveletMatrixProject)
library(ggplot2)
library(wavethresh)
#' Wavelet Matrix Construction
#'
#' Constructs a wavelet matrix using a high-pass filter, specified parameters, and an iterative process to build matrices.
#'
#' @param hf A vector representing the high-pass filter.
#' @param N An integer specifying the size of the wavelet matrix.
#' @param k An integer indicating the number of iterations.
#' @param shift An integer representing the shift to be applied.
#' @return A matrix representing the wavelet transformation.
#' @examples
#' hf <- c(0.5, -0.5)
#' N <- 4
#' k <- 2
#' shift <- 1
#' W <- WavmatND(hf, N, k, shift)
#' @export
#' @importFrom Matrix Diagonal
#' @import ggplot2
#' @import imager
#' @import pracma
#' @import ggplot2
#' @import gridExtra
WavmatND <- function(hf, N, k, shift) {
gf <- rev(Conj(hf) * (-1)^(1:length(hf)))
W <- matrix(nrow = 0, ncol = N)
hmatold <- diag(N)
h <- c(hf, rep(0, N))
g <- c(gf, rep(0, N))
for (i in 1:k) {
gmat <- matrix(0, nrow = N, ncol = N)
hmat <- matrix(0, nrow = N, ncol = N)
for (jj in 1:N) {
for (ii in 1:N) {
modulus <- (N + ii - jj - shift) %% N + 1
modulus <- modulus + (modulus == 0) * N
hmat[ii, jj] <- h[modulus]
gmat[ii, jj] <- g[modulus]
}
}
W <- rbind(t(gmat) %*% hmatold, W)
smooth <- t(hmat) %*% hmatold
hmatold <- smooth
h <- c(dilate_filter(hf, 2^(i) - 1), rep(0, N))
g <- c(dilate_filter(gf, 2^(i) - 1), rep(0, N))
}
W <- rbind(smooth, W)
return(W)
}
#' Dilate Filter
#'
#' Inserts zeros between the elements of the input filter to dilate it.
#'
#' @param filt A vector representing the filter to be dilated.
#' @param k An integer specifying the step size for dilation.
#' @return A vector of the dilated filter.
#' @examples
#' filt <- c(0.5, -0.5)
#' dilated_filt <- dilate_filter(filt, 2)
#' @export
dilate_filter <- function(filt, k) {
newlength <- (k + 1) * length(filt) - k
filtd <- rep(0, newlength)
filtd[seq(1, newlength, by = k + 1)] <- filt
return(filtd)
}
#' Imbed Vector
#'
#' Embeds a vector by appending zeros to double its length.
#'
#' @param a A vector to be embedded.
#' @return A vector with zeros appended to double its length.
#' @examples
#' a <- c(1, 2, 3)
#' imbedded_a <- imbed(a)
#' @export
imbed <- function(a) {
b <- c(a, rep(0, length(a)))
return(b)
}
#' Repeat Vector
#'
#' Repeats the input vector a specified number of times.
#'
#' @param a A vector to be repeated.
#' @param n An integer specifying the number of times to repeat the vector.
#' @return A vector with repeated elements.
#' @examples
#' a <- c(1, 2)
#' repeated_a <- repeating(a, 3)
#' @export
repeating <- function(a, n) {
b <- rep(a, n)
return(b)
}
library(WaveletMatrixProject)
library(gridExtra)
sigma <- 0.05
m <- 250  # noise level, signal size
t <- seq(1/m, 1, length.out = m)
s <- sqrt(t * (1 - t)) * sin((2 * pi * 1.05) / (t + 0.05))  # Generate a doppler signal
noise <- rnorm(m, 0, sigma)
sn <- s + noise  # a noisy doppler signal
J <- floor(log2(m))
k <- J - 1  # decomposition level
qmf <- c(1/sqrt(2), 1/sqrt(2))  # Haar wavelet
W <- WavmatND(qmf, m, k, 0)  # wavematND
weight <- function(m, k) {
size <- (k + 1) * m # Total size for the matrix (5000 when k = 4 and n = 1000)
T <- matrix(0, nrow = size, ncol = size)  # Initialize an empty matrix
# Assign weights so that the trace of T sums up to n (1000 in this case)
for (i in 1:(k + 1)) {
start_row <- (i - 1) * m + 1
end_row <- i * m
weight_value <- 1 / (k + 1)  # Ensure the sum of the weights in each block scales correctly
T[start_row:end_row, start_row:end_row] <- diag(weight_value, m, m)
}
return(T)
}
T <- weight(m, k)
# Transform the noisy signal using the wavelet matrix
tsn <- W %*% sn  # Transformed signal
# Hard-thresholding for denoising
sigmahat <- (var(tsn[(m + 1):(2 * m)][seq(1, length(tsn[(m + 1):(2 * m)]), 2)]) +
var(tsn[(m + 1):(2 * m)][seq(2, length(tsn[(m + 1):(2 * m)]), 2)])) / 2
threshold <- sqrt(2 * log(k * m) * sigmahat)
snt <- tsn[(m + 1):length(tsn)] * (abs(tsn[(m + 1):length(tsn)]) > threshold)
# Reconstruct the signal using inverse transform
rs <- W %*% T %*% c(tsn[1:m], snt)
dim(W)
dim(T)
# Reconstruct the signal using inverse transform
# Apply the weight matrix to the transformed signal (details only)
snt_weighted <- T %*% c(tsn[1:m], snt)
# Reconstruct the signal using the transpose of W (inverse transformation)
rs <- t(W) %*% snt_weighted
# Plot denoising results
p1 <- ggplot2::ggplot(data.frame(x = 1:m, y = s), ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("Original doppler signal") +
ggplot2::xlim(0, m)
p2 <- ggplot2::ggplot(data.frame(x = 1:m, y = sn), ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("Noisy doppler signal") +
ggplot2::xlim(0, m)
p3 <- ggplot2::ggplot(data.frame(x = 1:m, y = rs[1:m]), ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("De-noised doppler signal") +
ggplot2::xlim(0, m)
gridExtra::grid.arrange(p1, p2, p3, ncol = 3)
library(WaveletMatrixProject)
library(gridExtra)
sigma <- 0.05
m <- 250  # noise level, signal size
t <- seq(1/m, 1, length.out = m)
s <- sqrt(t * (1 - t)) * sin((2 * pi * 1.05) / (t + 0.05))  # Generate a doppler signal
noise <- rnorm(m, 0, sigma)
sn <- s + noise  # a noisy doppler signal
J <- floor(log2(m))
k <- J - 1  # decomposition level
qmf <- c(1/sqrt(2), 1/sqrt(2))  # Haar wavelet
W <- WavmatND(qmf, m, k, 0)  # wavematND
weight <- function(m, k) {
size <- (k + 1) * m # Total size for the matrix (5000 when k = 4 and n = 1000)
T <- matrix(0, nrow = size, ncol = size)  # Initialize an empty matrix
# Assign weights so that the trace of T sums up to n (1000 in this case)
for (i in 1:(k + 1)) {
start_row <- (i - 1) * m + 1
end_row <- i * m
weight_value <- 1 / (k + 1)  # Ensure the sum of the weights in each block scales correctly
T[start_row:end_row, start_row:end_row] <- diag(weight_value, m, m)
}
return(T)
}
T <- weight(m, k)
# Transform the noisy signal using the wavelet matrix
tsn <- W %*% sn  # Transformed signal
# Hard-thresholding for denoising
sigmahat <- (var(tsn[(m + 1):(2 * m)][seq(1, length(tsn[(m + 1):(2 * m)]), 2)]) +
var(tsn[(m + 1):(2 * m)][seq(2, length(tsn[(m + 1):(2 * m)]), 2)])) / 2
threshold <- sqrt(2 * log(k * m) * sigmahat)
snt <- tsn[(m + 1):length(tsn)] * (abs(tsn[(m + 1):length(tsn)]) > threshold)
# Reconstruct the signal using inverse transform
# Apply the weight matrix to the transformed signal (details only)
snt_weighted <- T %*% c(tsn[1:m], snt)
# Reconstruct the signal using the transpose of W (inverse transformation)
rs <- t(W) %*% snt_weighted
# Plot denoising results
p1 <- ggplot2::ggplot(data.frame(x = 1:m, y = s), ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("Original doppler signal") +
ggplot2::xlim(0, m)
p2 <- ggplot2::ggplot(data.frame(x = 1:m, y = sn), ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("Noisy doppler signal") +
ggplot2::xlim(0, m)
p3 <- ggplot2::ggplot(data.frame(x = 1:m, y = rs[1:m]), ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("De-noised doppler signal") +
ggplot2::xlim(0, m)
# Create a data frame for plotting the transformed noisy signal
tsn_data <- data.frame(x = 1:(m * (k + 1)), y = tsn)
# Create the plot for the transformed noisy doppler signal
p4 <- ggplot2::ggplot(tsn_data, ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("Transformed noisy doppler signal with NDWT") +
ggplot2::xlim(0, m * (k + 1))
# Arrange the plots in a 2x3 grid layout
gridExtra::grid.arrange(p1, p2, p3, p4, layout_matrix = matrix(c(1, 2, 3, 4, 4, 4), nrow = 2, byrow = TRUE))
library(WaveletMatrixProject)
library(gridExtra)
sigma <- 0.05
m <- 250  # noise level, signal size
t <- seq(1/m, 1, length.out = m)
s <- sqrt(t * (1 - t)) * sin((2 * pi * 1.05) / (t + 0.05))  # Generate a doppler signal
noise <- rnorm(m, 0, sigma)
sn <- s + noise  # a noisy doppler signal
J <- floor(log2(m))
k <- J - 1  # decomposition level
qmf <- c(1/sqrt(2), 1/sqrt(2))  # Haar wavelet
W <- WavmatND(qmf, m, k, 0)  # wavematND
weight <- function(m, k) {
size <- (k + 1) * m # Total size for the matrix (5000 when k = 4 and n = 1000)
T <- matrix(0, nrow = size, ncol = size)  # Initialize an empty matrix
# Assign weights so that the trace of T sums up to n (1000 in this case)
for (i in 1:(k + 1)) {
start_row <- (i - 1) * m + 1
end_row <- i * m
weight_value <- 1 / (k + 1)  # Ensure the sum of the weights in each block scales correctly
T[start_row:end_row, start_row:end_row] <- diag(weight_value, m, m)
}
return(T)
}
T <- weight(m, k)
# Transform the noisy signal using the wavelet matrix
tsn <- W %*% sn  # Transformed signal
# Hard-thresholding for denoising
sigmahat <- (var(tsn[(m + 1):(2 * m)][seq(1, length(tsn[(m + 1):(2 * m)]), 2)]) +
var(tsn[(m + 1):(2 * m)][seq(2, length(tsn[(m + 1):(2 * m)]), 2)])) / 2
threshold <- sqrt(2 * log(k * m) * sigmahat)
snt <- tsn[(m + 1):length(tsn)] * (abs(tsn[(m + 1):length(tsn)]) > threshold)
# Reconstruct the signal using inverse transform
# Apply the weight matrix to the transformed signal (details only)
snt_weighted <- T %*% c(tsn[1:m], snt)
# Reconstruct the signal using the transpose of W (inverse transformation)
rs <- t(W) %*% snt_weighted
# Plot denoising results
p1 <- ggplot2::ggplot(data.frame(x = 1:m, y = s), ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("Original doppler signal") +
ggplot2::xlim(0, m)
p2 <- ggplot2::ggplot(data.frame(x = 1:m, y = sn), ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("Noisy doppler signal") +
ggplot2::xlim(0, m)
# Correct the data for the de-noised signal plot
denoised_data <- data.frame(x = 1:m, y = rs[1:m])
# Create the plot for the de-noised doppler signal
p3 <- ggplot2::ggplot(denoised_data, ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("De-noised doppler signal") +
ggplot2::xlim(0, m)
# Create a data frame for plotting the transformed noisy signal
tsn_data <- data.frame(x = 1:(m * (k + 1)), y = tsn)
# Create the plot for the transformed noisy doppler signal
p4 <- ggplot2::ggplot(tsn_data, ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("Transformed noisy doppler signal with NDWT") +
ggplot2::xlim(0, m * (k + 1))
# Arrange the plots in a 2x3 grid layout
gridExtra::grid.arrange(p1, p2, p3, p4, layout_matrix = matrix(c(1, 2, 3, 4, 4, 4), nrow = 2, byrow = TRUE))
library(WaveletMatrixProject)
library(gridExtra)
sigma <- 0.05
m <- 250  # noise level, signal size
t <- seq(1/m, 1, length.out = m)
s <- sqrt(t * (1 - t)) * sin((2 * pi * 1.05) / (t + 0.05))  # Generate a doppler signal
noise <- rnorm(m, 0, sigma)
sn <- s + noise  # a noisy doppler signal
J <- floor(log2(m))
k <- J - 1  # decomposition level
qmf <- c(1/sqrt(2), 1/sqrt(2))  # Haar wavelet
W <- WavmatND(qmf, m, k, 0)  # wavematND
weight <- function(m, k) {
size <- (k + 1) * m # Total size for the matrix (5000 when k = 4 and n = 1000)
T <- matrix(0, nrow = size, ncol = size)  # Initialize an empty matrix
# Assign weights so that the trace of T sums up to n (1000 in this case)
for (i in 1:(k + 1)) {
start_row <- (i - 1) * m + 1
end_row <- i * m
weight_value <- 1 / (k + 1)  # Ensure the sum of the weights in each block scales correctly
T[start_row:end_row, start_row:end_row] <- diag(weight_value, m, m)
}
return(T)
}
T <- weight(m, k)
# Transform the noisy signal using the wavelet matrix
tsn <- W %*% sn  # Transformed signal
# Hard-thresholding for denoising
# Estimate noise level from the detail coefficients
sigmahat <- (var(tsn[(m + 1):length(tsn)][seq(1, length(tsn[(m + 1):length(tsn)]), 2)]) +
var(tsn[(m + 1):length(tsn)][seq(2, length(tsn[(m + 1):length(tsn)]), 2)])) / 2
# Calculate the threshold
threshold <- sqrt(2 * log(k * m) * sigmahat)
# Apply hard-thresholding to the detail coefficients
snt <- tsn[(m + 1):length(tsn)] * (abs(tsn[(m + 1):length(tsn)]) > threshold)
# Combine approximation coefficients and thresholded detail coefficients
tsn_combined <- c(tsn[1:m], snt)
# Reconstruct the signal using the inverse transformation (transpose of W)
rs <- t(W) %*% T %*% tsn_combined  # Ensure T is applied to maintain the same transformation as in MATLAB
# Plot denoising results
p1 <- ggplot2::ggplot(data.frame(x = 1:m, y = s), ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("Original doppler signal") +
ggplot2::xlim(0, m)
p2 <- ggplot2::ggplot(data.frame(x = 1:m, y = sn), ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("Noisy doppler signal") +
ggplot2::xlim(0, m)
# Correct the data for the de-noised signal plot
denoised_data <- data.frame(x = 1:m, y = rs[1:m])
# Create the plot for the de-noised doppler signal
p3 <- ggplot2::ggplot(denoised_data, ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("De-noised doppler signal") +
ggplot2::xlim(0, m)
# Create a data frame for plotting the transformed noisy signal
tsn_data <- data.frame(x = 1:(m * (k + 1)), y = tsn)
# Create the plot for the transformed noisy doppler signal
p4 <- ggplot2::ggplot(tsn_data, ggplot2::aes(x, y)) +
ggplot2::geom_line() +
ggplot2::ggtitle("Transformed noisy doppler signal with NDWT") +
ggplot2::xlim(0, m * (k + 1))
# Arrange the plots in a 2x3 grid layout
gridExtra::grid.arrange(p1, p2, p3, p4, layout_matrix = matrix(c(1, 2, 3, 4, 4, 4), nrow = 2, byrow = TRUE))
document()
install.packages("devtools")
library(devtools)
devtools::document()
rm(list = c("dilate_filter", "imbed", "repeating", "WavmatND"))
devtools::load_all()
document()
devtools::check()
document()
document()
devtools::check()
