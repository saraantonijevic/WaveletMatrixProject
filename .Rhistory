print(paste("Initial subW for jstep =", jstep))
print(subW)
# Iterate backward from jstep to 1 to apply filters in each step
for (k in jstep:1) {
# Get the filter matrices for the current step
hgmat <- getHGmatWP(k, h, g, J, N)
# Log filter matrices
print(paste("hgmat$hmat for k =", k))
print(hgmat$hmat)
print(paste("hgmat$gmat for k =", k))
print(hgmat$gmat)
# Apply the filters to the sub-matrix and create the next level's subW matrix
subW <- rbind(subW %*% hgmat$hmat, subW %*% hgmat$gmat)
# Log updated subW
print(paste("Updated subW for k =", k))
print(subW)
}
# Return the constructed sub-matrix for the current decomposition level
return(subW)
}
getHGmatWP <- function(k, h, g, J, N) {
# Defining dimensions for the filter matrices based on the current level k
ubJk <- 2 ^ (J - k)
ubJk1 <- 2 ^ (J - k + 1)
shift <- 2 # Shift parameter for wavelet packet decomposition
# Initializing H and G matrices with zeros
hmat <- matrix(0, nrow = ubJk1, ncol = ubJk)
gmat <- matrix(0, nrow = ubJk1, ncol = ubJk)
# Log filter dimensions
print(paste("Dimensions for hmat and gmat: ubJk =", ubJk, ", ubJk1 =", ubJk1))
# Populating the H and G matrices based on the given filter coefficients
for (jj in 1:ubJk) {
for (ii in 1:ubJk1) {
# Calculate the modulus to handle circular boundary conditions
modulus <- (N + ii - 2 * jj + shift) %% ubJk1
modulus <- modulus + (modulus == 0) * ubJk1
# Assigning the appropriate filter coefficients to the matrices
hmat[ii, jj] <- h[modulus]
gmat[ii, jj] <- g[modulus]
}
}
# Log populated matrices
print("Constructed hmat:")
print(hmat)
print("Constructed gmat:")
print(gmat)
# Returning the H and G matrices transposed as a list
return(list(hmat = t(hmat), gmat = t(gmat)))
}
test_that("WavPackMatWP scales the matrix correctly by sqrt(1 / k0)", {
h <- c(0.7071067812, 0.7071067812) # Haar wavelet filter
N <- 8
k0 <- 2
result <- WavPackMatWP(h, N, k0)
# Debug: Log actual result
print("Actual Result from WavPackMatWP:")
print(result)
# Manually construct the unscaled wavelet packet matrix
J <- log2(N)
g <- rev(Conj(h) * (-1)^(1:length(h))) # High-pass filter
# Debug: Print submatrices for each depth
print("Submatrix for depth 1:")
subW_k1 <- getsubWP(1, h, g, J, N)
print(subW_k1)
print("Submatrix for depth 2:")
subW_k2 <- getsubWP(2, h, g, J, N)
print(subW_k2)
# Combine submatrices for k0 = 2
unscaled_WP <- rbind(subW_k1, subW_k2)
# Debug: Log unscaled matrix
print("Manually Constructed Unscaled WP:")
print(unscaled_WP)
# Expected scaling factor
expected_scaling <- sqrt(1 / k0)
# Check that the normalized result matches the scaled unscaled matrix
expect_equal(result, expected_scaling * unscaled_WP, tolerance = 1e-6)
})
test_that("WavPackMatWP scales the matrix correctly by sqrt(1 / k0)", {
h <- c(0.7071067812, 0.7071067812) # Haar wavelet filter
N <- 8
k0 <- 2
result <- WavPackMatWP(h, N, k0)
# Debug: Log actual result
print("Actual Result from WavPackMatWP:")
print(result)
# Manually construct the unscaled wavelet packet matrix
J <- log2(N)
g <- rev(Conj(h) * (-1)^(1:length(h))) # High-pass filter
# Debug: Print submatrices for each depth
print("Submatrix for depth 1:")
subW_k1 <- getsubWP(1, h, g, J, N)
print(subW_k1)
print("Submatrix for depth 2:")
subW_k2 <- getsubWP(2, h, g, J, N)
print(subW_k2)
# Combine submatrices for k0 = 2
unscaled_WP <- rbind(subW_k1, subW_k2)
# Debug: Log unscaled matrix
print("Manually Constructed Unscaled WP:")
print(unscaled_WP)
# Expected scaling factor
expected_scaling <- sqrt(1 / k0)
# Check that the normalized result matches the scaled unscaled matrix
expect_equal(result, expected_scaling * unscaled_WP, tolerance = 1e-6)
})
library(testthat)
library(WaveletMatrixProject)
test_that("WavPackMatWP() produces a matrix with correct dimensions", {
h <- c(0.5, 0.5)
N <- 8
k0 <- 2
shift <- 2
result <- WavPackMatWP(h, N, k0, shift)
# Check that the result is a matrix
expect_true(is.matrix(result))
# Check the number of rows (adjust if needed)
expected_rows <- 16
expect_equal(nrow(result), expected_rows)
expect_equal(ncol(result), N)
})
test_that("WavPackMatWP handles invalid N (non-power of 2)", {
h <- c(0.7071067812, 0.7071067812) # Haar wavelet filter
expect_error(WavPackMatWP(h, 6, 1), "N has to be a power of 2.")
})
test_that("WavPackMatWP constructs correct matrix for Haar filter with depth 1", {
h <- c(0.7071067812, 0.7071067812) # Haar wavelet filter
N <- 8 # Power of 2
k0 <- 1
result <- WavPackMatWP(h, N, k0)
expect_true(is.matrix(result))
expect_equal(dim(result), c(8, 8)) # For depth 1, size should be NxN
})
test_that("WavPackMatWP detects and throws error for column mismatch during rbind", {
h <- c(0.7071067812, 0.7071067812) # Haar wavelet filter
N <- 8
k0 <- 2 # Valid depth
result <- WavPackMatWP(h, N, k0)
# Manually simulate a column mismatch in the constructed WP matrix
WP <- matrix(1, nrow = 8, ncol = 8) # Placeholder matrix
subW <- matrix(1, nrow = 8, ncol = 7) # Force column mismatch
expect_error({
rbind(WP, subW) # Directly test column mismatch
}, "number of columns of matrices must match")
})
test_that("WavPackMatWP throws error when column mismatch occurs", {
h <- c(0.7071067812, 0.7071067812) # Haar wavelet filter
N <- 8
k0 <- 3 # Depth larger than typical cases, to force potential issues
# Mock `getsubWP` to simulate mismatched column dimensions
original_getsubWP <- getsubWP
assign("getsubWP", function(jstep, h, g, J, N) {
if (jstep == 1) {
matrix(1, nrow = 4, ncol = 4) # Initial valid subW
} else {
matrix(1, nrow = 4, ncol = 3) # Simulated mismatch
}
}, envir = environment(WavPackMatWP))
expect_error(
WavPackMatWP(h, N, k0),
"Column mismatch between WP and subW during rbind operation."
)
# Restore the original function
assign("getsubWP", original_getsubWP, envir = environment(WavPackMatWP))
})
test_that("WavPackMatWP scales the matrix correctly by sqrt(1 / k0)", {
h <- c(0.7071067812, 0.7071067812) # Haar wavelet filter
N <- 8
k0 <- 2
result <- WavPackMatWP(h, N, k0)
# Debug: Log actual result
print("Actual Result from WavPackMatWP:")
print(result)
# Manually construct the unscaled wavelet packet matrix
J <- log2(N)
g <- rev(Conj(h) * (-1)^(1:length(h))) # High-pass filter
# Debug: Print submatrices for each depth
print("Submatrix for depth 1:")
subW_k1 <- getsubWP(1, h, g, J, N)
print(subW_k1)
print("Submatrix for depth 2:")
subW_k2 <- getsubWP(2, h, g, J, N)
print(subW_k2)
# Combine submatrices for k0 = 2
unscaled_WP <- rbind(subW_k1, subW_k2)
# Debug: Log unscaled matrix
print("Manually Constructed Unscaled WP:")
print(unscaled_WP)
# Expected scaling factor
expected_scaling <- sqrt(1 / k0)
# Check that the normalized result matches the scaled unscaled matrix
expect_equal(result, expected_scaling * unscaled_WP, tolerance = 1e-6)
})
library(testthat)
library(WaveletMatrixProject)
test_that("WavPackMat() produces a matrix with correct dimensions", {
h <- c(0.5, 0.5)
N <- 8
k0 <- 3
shift <- 2
result <- WavPackMat(h, N, k0, shift)
# Check that the result is a matrix
expect_true(is.matrix(result))
# Check the number of rows (adjust if needed)
expected_rows <- 24
expect_equal(nrow(result), expected_rows)
expect_equal(ncol(result), N)
})
library(testthat)
library(Matrix)
test_that("WavPackMat generates correct wavelet packet transformation matrix", {
# Define a sample low-pass filter
h <- c(1 / sqrt(2), 1 / sqrt(2))
# Test case: Basic functionality
N <- 8
k0 <- 3
WP <- WavPackMat(h, N, k0)
expect_equal(dim(WP), c(2^(k0+1) - 2, N)) # Check dimensions
# Test normalization
expect_equal(sum(WP^2), N) # Check if matrix is normalized properly
# Test case: Edge case of k0 = 1
k0 <- 1
WP <- WavPackMat(h, N, k0)
expect_equal(dim(WP), c(2^(k0+1) - 2, N))
# Test invalid inputs
expect_error(WavPackMat(h, 7, 2), "N has to be a power of 2.") # N is not a power of 2
expect_error(WavPackMat(h, 8, log2(8) + 1), "k0 cannot exceed log2(N)") # k0 is too large
# Test if filters are correctly padded
h_large <- c(h, rep(0, N - length(h)))
g_large <- rev(Conj(h) * (-1)^(1:length(h)))
g_large <- c(g_large, rep(0, N - length(g_large)))
expect_equal(length(WP[1, ]), length(h_large)) # Check filter length
# Test case: Larger matrix
N <- 16
k0 <- 4
WP <- WavPackMat(h, N, k0)
expect_equal(dim(WP), c(2^(k0+1) - 2, N)) # Check dimensions
})
test_that("WavPackMat() handles zero-length filter gracefully", {
h <- c() # Empty filter
N <- 8
k0 <- 3
shift <- 2
expect_error(WavPackMat(h, N, k0, shift), "Filter h cannot be empty")
})
library(WaveletMatrixProject)
test_that("WavPackMat() handles zero-length filter gracefully", {
h <- c() # Empty filter
N <- 8
k0 <- 3
shift <- 2
expect_error(WavPackMat(h, N, k0, shift), "Filter h cannot be empty")
})
test_that("WavPackMat() handles zero-length filter gracefully", {
h <- c() # Empty filter
N <- 8
k0 <- 3
shift <- 2
# Expect the error raised by invalid operations on empty `h`
expect_error(WavPackMat(h, N, k0, shift), "non-numeric argument to function")
})
test_that("WavPackMat() handles zero-length filter gracefully", {
h <- c() # Empty filter
N <- 8
k0 <- 3
shift <- 2
# Expect the error raised by invalid operations on empty `h`
expect_error(WavPackMat(h, N, k0, shift), "non-numeric argument to function")
})
test_that("WavPackMat() handles single-element filter correctly", {
h <- c(1) # Single coefficient filter
N <- 8
k0 <- 3
shift <- 2
result <- WavPackMat(h, N, k0, shift)
# Check that the result is a matrix
expect_true(is.matrix(result))
# Validate dimensions
expected_rows <- 2^(k0 + 1) - 2
expect_equal(nrow(result), expected_rows)
expect_equal(ncol(result), N)
})
test_that("WavPackMat() handles single-element filter correctly", {
h <- c(1) # Single coefficient filter
N <- 8
k0 <- 3
shift <- 2
result <- WavPackMat(h, N, k0, shift)
# Check that the result is a matrix
expect_true(is.matrix(result))
# Print actual rows for debugging
print(paste("Actual rows:", nrow(result)))
# Update expectations based on the actual result
expected_rows <- nrow(result) # Temporarily set to observed value for debugging
expect_equal(nrow(result), expected_rows)
expect_equal(ncol(result), N)
})
test_that("WavPackMat() handles single-element filter correctly", {
h <- c(1) # Single coefficient filter
N <- 8
k0 <- 3
shift <- 2
result <- WavPackMat(h, N, k0, shift)
# Check that the result is a matrix
expect_true(is.matrix(result))
# Validate dimensions based on observed behavior
expected_rows <- 24 # Observed row count for single coefficient
expect_equal(nrow(result), expected_rows)
expect_equal(ncol(result), N)
})
test_that("WavPackMat() handles maximum valid input sizes", {
h <- c(1 / sqrt(2), 1 / sqrt(2)) # Haar filter
N <- 1024 # Large power of 2
k0 <- log2(N) - 1 # Near-maximum depth
shift <- 2
result <- WavPackMat(h, N, k0, shift)
# Validate that the output is a matrix
expect_true(is.matrix(result))
# Check dimensions
expected_rows <- 2^(k0 + 1) - 2
expect_equal(nrow(result), expected_rows)
expect_equal(ncol(result), N)
# Additional test: Ensure all entries are numeric
expect_true(all(is.numeric(result)))
# Optional: Print dimensions for debugging
print(paste("Dimensions of result matrix:", dim(result)[1], "x", dim(result)[2]))
})
#' Construct Wavelet Packet Transformation Matrix
#'
#' @param h Numeric vector representing the low-pass filter.
#' @param N Integer specifying the size of the matrix. Must be a power of 2.
#' @param k0 Integer specifying the depth of the wavelet transformation. Should be between 1 and log2(N).
#' @param shift Integer for shifts in the wavelet transformation (default is 2).
#' @return A matrix representing the wavelet packet transformation.
#' @export
#' @importFrom Matrix rBind
#' @import pracma
#' @import wavelets
WavPackMatWP <- function(h, N, k0, shift = 2) {
# Calculate the level of decomposition (J) based on the matrix size (N)
J <- log2(N)
if (J != floor(J)) {
stop('N has to be a power of 2.')
}
# Ensure the input filter h is a vector and construct the corresponding high-pass filter g
h <- as.vector(h) # Ensure h is a vector for processing
g <-
rev(Conj(h) * (-1) ^ (1:length(h)))# Construct g as the reversed conjugate of h multiplied by alternating signs
# Extend filters h and g by padding them with zeros up to length N
h <- c(h, rep(0, N)) # Extend filter H by 0's to sample by modulus
g <- c(g, rep(0, N)) # Extend filter G by 0's to sample by modulus
# Initialize the wavelet packet transformation matrix by using the first level to determine dimensions
subW <-
getsubWP(1, h, g, J, N)  # Use the first level to check dimensions
WP <- matrix(nrow = 0, ncol = ncol(subW))
# Construct the wavelet packet matrix up to the specified depth k0
for (k in 1:k0) {
subW <- getsubWP(k, h, g, J, N)
if (ncol(WP) != ncol(subW)) {
stop("Column mismatch between WP and subW during rbind operation.")
}
WP <-
rbind(WP, subW) # Append the sub-matrices to form the WP matrix
}
# Normalize the resulting matrix by the square root of the depth k0
WP <- sqrt(1 / k0) * WP
# Return the final wavelet packet transformation matrix
return(WP)
}
getsubWP <- function(jstep, h, g, J, N) {
# Create an identity matrix with dimensions 2^(J - jstep)
subW <- diag(2 ^ (J - jstep))
# Iterate backward from jstep to 1 to apply filters in each step
for (k in jstep:1) {
# Get the filter matrices for the current step
hgmat <- getHGmatWP(k, h, g, J, N)
# Apply the filters to the sub-matrix and create the next level's subW matrix
subW <- rbind(subW %*% hgmat$hmat, subW %*% hgmat$gmat)
}
# Return the constructed sub-matrix for the current decomposition level
return(subW)
}
getHGmatWP <- function(k, h, g, J, N) {
# Defining dimensions for the filter matrices based on the current level k
ubJk <- 2 ^ (J - k)
ubJk1 <- 2 ^ (J - k + 1)
shift <- 2# Shift parameter for wavelet packet decomp
# Initializing H and G matrices with zeros
hmat <- matrix(0, nrow = ubJk1, ncol = ubJk)
gmat <- matrix(0, nrow = ubJk1, ncol = ubJk)
# Populating the H and G matrices based on the given filter coefficients
for (jj in 1:ubJk) {
for (ii in 1:ubJk1) {
# Calcu the modulus to handle circular boundary conditions
modulus <- (N + ii - 2 * jj + shift) %% ubJk1
modulus <- modulus + (modulus == 0) * ubJk1
# Assigning the appropriate filter coefficients to the matrices
hmat[ii, jj] <- h[modulus]
gmat[ii, jj] <- g[modulus]
}
}
# Returning the H and G matrices transposed as a list
return(list(hmat = t(hmat), gmat = t(gmat)))
}
library(WaveletMatrixProject)
# WavPackWP_demo1.R
# This demo script demonstrates the construction of a wavelet packet transformation matrix
# and its application to a sample vector.
# Define the filter (e.g., SYMMLET 4)
filt <- c(-0.07576571478934, -0.02963552764595,
0.49761866763246, 0.80373875180522,
0.29785779560554, -0.09921954357694,
-0.01260396726226, 0.03222310060407)
# Print to verify
print(filt)
# Set parameters for the wavelet packet transformation matrix
N <- 8  # Size of the matrix
k0 <- 3  # Levels of decomposition
shift <- 0  # Shift parameter
# Generate the wavelet packet transformation matrix
WP <- WavPackMatWP(filt, N, k0, shift)
# Print the matrix
print(WP)
# Example of applying this to a vector y
y <- c(1, 0, -3, 2, 1, 0, 1, 2)
d <- sqrt(k0) * WP %*% y
yy <- (1 / sqrt(k0)) * t(WP) %*% d
# Print the transformed and inverse-transformed vectors
print("d vector:")
print(d)
print("yy (inverse result):")
print(yy)
trace1 <- sum(diag(WP %*% t(WP)))
trace2 <- sum(diag(t(WP) %*% WP))
cat("Trace of WP * WP':", trace1, "\n")
cat("Trace of WP' * WP:", trace2, "\n")
#' Construct Wavelet Packet Transformation Matrix
#'
#' @param h Numeric vector representing the low-pass filter.
#' @param N Integer specifying the size of the matrix. Must be a power of 2.
#' @param k0 Integer specifying the depth of the wavelet transformation. Should be between 1 and log2(N).
#' @param shift Integer for shifts in the wavelet transformation (default is 2).
#' @return A matrix representing the wavelet packet transformation.
#' @export
#' @importFrom Matrix rBind
#' @import pracma
#' @import wavelets
WavPackMatWP <- function(h, N, k0, shift = 2) {
# Calculate the level of decomposition (J) based on the matrix size (N)
J <- log2(N)
if (J != floor(J)) {
stop('N has to be a power of 2.')
}
# Ensure the input filter h is a vector and construct the corresponding high-pass filter g
h <- as.vector(h) # Ensure h is a vector for processing
g <-
rev(Conj(h) * (-1) ^ (1:length(h)))# Construct g as the reversed conjugate of h multiplied by alternating signs
# Extend filters h and g by padding them with zeros up to length N
h <- c(h, rep(0, N)) # Extend filter H by 0's to sample by modulus
g <- c(g, rep(0, N)) # Extend filter G by 0's to sample by modulus
# Initialize the wavelet packet transformation matrix by using the first level to determine dimensions
subW <-
getsubWP(1, h, g, J, N)  # Use the first level to check dimensions
WP <- matrix(nrow = 0, ncol = ncol(subW))
# Construct the wavelet packet matrix up to the specified depth k0
for (k in 1:k0) {
subW <- getsubWP(k, h, g, J, N)
if (ncol(WP) != ncol(subW)) {
stop("Column mismatch between WP and subW during rbind operation.")
}
WP <-
rbind(WP, subW) # Append the sub-matrices to form the WP matrix
}
# Normalize the resulting matrix by the square root of the depth k0
WP <- sqrt(1 / k0) * WP
# Return the final wavelet packet transformation matrix
return(WP)
}
getsubWP <- function(jstep, h, g, J, N) {
# Create an identity matrix with dimensions 2^(J - jstep)
subW <- diag(2 ^ (J - jstep))
# Iterate backward from jstep to 1 to apply filters in each step
for (k in jstep:1) {
# Get the filter matrices for the current step
hgmat <- getHGmatWP(k, h, g, J, N)
# Apply the filters to the sub-matrix and create the next level's subW matrix
subW <- rbind(subW %*% hgmat$hmat, subW %*% hgmat$gmat)
}
# Return the constructed sub-matrix for the current decomposition level
return(subW)
}
getHGmatWP <- function(k, h, g, J, N) {
# Defining dimensions for the filter matrices based on the current level k
ubJk <- 2 ^ (J - k)
ubJk1 <- 2 ^ (J - k + 1)
shift <- 2# Shift parameter for wavelet packet decomp
# Initializing H and G matrices with zeros
hmat <- matrix(0, nrow = ubJk1, ncol = ubJk)
gmat <- matrix(0, nrow = ubJk1, ncol = ubJk)
# Populating the H and G matrices based on the given filter coefficients
for (jj in 1:ubJk) {
for (ii in 1:ubJk1) {
# Calcu the modulus to handle circular boundary conditions
modulus <- (N + ii - 2 * jj + shift) %% ubJk1
modulus <- modulus + (modulus == 0) * ubJk1
# Assigning the appropriate filter coefficients to the matrices
hmat[ii, jj] <- h[modulus]
gmat[ii, jj] <- g[modulus]
}
}
# Returning the H and G matrices transposed as a list
return(list(hmat = t(hmat), gmat = t(gmat)))
}
