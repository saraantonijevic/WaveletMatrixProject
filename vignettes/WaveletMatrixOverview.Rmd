---
title: "WaveletMatrixOverview"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{WaveletMatrixOverview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

```{r setup}
library(WaveletMatrixProject)
```

# Introduction

The `WaveletMatrixProject` is a comprehensive package for the construction and manipulation of wavelets and wavelet transformation matrices. These tools are essential for signal processing tasks, such as:

- Decomposing signals into multiple resolutions.
- Analyzing frequency components across different scales.
- Enhancing feature extraction and reconstructring signals from wavelet transformations.

This vignette serves as a guide to the package, composing of:

- **Detailed Core-Function Descriptions**: Clear explanations of each function's purpose and role in signal processing.
- **Code Examples**: Step-by-step demonstrations to help you understand usage.
- **Visual Outputs**: Graphs and plots to illustrate the effects of transformations.

By the end of this vignette, you will be able to:

- Construct wavelets and wavelet packet matrices using the functions.
- Apply advanced transformations for multi-resolution signal analysis.
- Combine supporting utilities like filter dilation and vector embedding to enhance workflow.

Explore `WaveletMatrixProject` and see how the tools can enhance signal processing capabilities.

#Core Functions

## 1. `WavmatND()`
**Description**: The WavmatND() function generates a wavelet matrix by iteratively applying a high-pass filter to an identity matrix. This then constructs a transformation matrix that captures the high-frequency details of a signal. The function is useful in non-decimated wavelet transforms where no down-sampling is performed. Therefore, it preserves the original signal length.

Key arguments:

- hf: Numeric vector representing the high-pass filter coefficients.
- N: Size of the wavelet matrix (signal length).
- k: The number of decomposition levels.
- shift: The number that indicates the shift needed to be applied to the filter at each iteration.

WavmatND() supports multi-resolution analysis by enabling signal decomposition at finer scales.

### Example
```{r WavmatND-example}
# Define parameters
hf <- c(0.5, -0.5) # High-pass filter
N <- 4  # Signal length
k <- 2  # Decomposition levels
shift <- 1  # Filter shift

# Construct the wavelet matrix
W <- WavmatND(hf, N, k, shift)
print(W)

image(W, main = "Wavelet Matrix (WavmatND)", xlab = "Columns", ylab = "Rows", col = heat.colors(256))
```
**Explanation**: The WavmatND() function starts with an identity matrix and applies a high-pass filter to construct the wavelet matrix. This matrix can be used for signal processing tasks where transformations are needed to capture specific frequency components in signals.

**Output**: The output is a matrix where each row represents the high-frequency components at a specific scale.

For a more detailed demonstration, please see WavmatND_demo1 and WavmatND_demo2 in the demos folder.

## 2. `dilate_filter()`
**Description**: This function dilates a filter by inserting zeros between its elements. This increases the filter's length without altering the original coefficients. This technique is commonly used in multi-resolution wavelet transformations, where filters which have varying lengths are required at different scales.

Key arguments:

-filt: This is a numeric vector which represents the original filter coefficients.
-step: This signifies the amount of zeros needed to inserted between each element.

### Example
```{r dilate_filter-example}
# Define a filter
filt <- c(0.5, -0.5)

# Dilate the filter with a step size of 2
dilated_filt <- dilate_filter(filt, 2)
print(dilated_filt)
```

**Explanation**: dilate_filter() takes an input vector and places zeros between its elements. This adjusts filter lengths in wavelet processing, where filters of specific lengths are required for different transformation levels.

Output: A vector where zeros are interspersed between the original filter coefficients.

Use Case: Used in conjunction with wavelet matrix construction to adapt filters for transformations across multiple levels.



## 3. `imbed()`
**Description**:  Embeds a vector by appending zeros to double its length. This operation is typically used in preparation for transformations that require vectors of greater length. construction.

### Example
```{r imbed-example}
# Original vector
a <- c(1, 2, 3)

# Embed the vector
imbedded_a <- imbed(a)
print(imbedded_a)
```

**Explanation**: imbed() increases the length of a vector by appending zeros, which can be required for padding in signal processing or when preparing data for further multi-resolution analysis.



## 4. `repeating()`
**Description**:  Repeats the input vector a specified number of times, creating a longer vector by replication. This is useful in creating extended signals or patterns.

### Example
```{r repeating-example}
# Original vector
a <- c(1, 2)

# Repeat the vector 3 times
repeated_a <- repeating(a, 3)
print(repeated_a)
```

**Explanation**: The repeating() function replicates the input vector n times, extending its length. This is beneficial in scenarios where repeated patterns of a signal are required for signal synthesis or analysis.



## 5. `WavPackMatWP()`
**Description**: Constructs a wavelet packet transformation matrix using a low-pass filter. This matrix represents a transformation that decomposes signals into components at different levels of detail.

### Example
```{r WavPackMatWP-example}
# Low-pass filter
h <- c(0.5, 0.5)
N <- 8
k0 <- 2
shift <- 2

# Construct the wavelet packet matrix
WP <- WavPackMatWP(h, N, k0, shift)
print(WP)
```

**Explanation**: WavPackMatWP() builds a matrix for wavelet packet transformation up to a depth k0. It uses the low-pass filter (h) to decompose the signal and create a matrix that captures different levels of detail. This function is essential for performing multi-resolution analysis.



## 6. `getsubWP()`
**Description**: Constructs sub-matrices for wavelet packet transformation at each level of decomposition. This function is used internally by WavPackMatWP().

### Example
This function is an essential part of WavPackMatWP() to iteratively create sub-matrices for each decomposition level.

**Explanation**: getsubWP() generates sub-matrices that represent transformations at different decomposition levels. It iterates backward through the levels, applying filter matrices to create detailed sub-matrices that contribute to the overall transformation matrix.



## 7. `getHGmatWP()`
**Description**: Constructs the H and G matrices for wavelet packet transformation, applying circular boundary conditions. This function is used internally by WavPackMatWP().

### Example
This function supports WavPackMatWP() by creating the necessary H and G filter matrices during matrix construction.

**Explanation**: getHGmatWP() computes matrices using the input filters (h and g), adjusting their elements with a modulus operation to handle boundary conditions. This ensures that the transformation correctly wraps around indices when applying the filters, which is critical in wavelet packet analysis.



## 8. `WavPackMat()`
**Description**: Constructs an optimized orthogonal wavelet transformation matrix using a low-pass filter. This matrix is used for efficient wavelet-based signal processing.

### Example
```{r WavPackMat-example}
# Low-pass filter
h <- c(0.5, 0.5)
N <- 8
k0 <- 3
shift <- 2

# Construct the wavelet transformation matrix
WP_opt <- WavPackMat(h, N, k0, shift)
print(WP_opt)
```

**Explanation**: WavPackMat() builds an orthogonal wavelet transformation matrix optimized for computational efficiency. This matrix is essential for analyzing signals with high precision and low computational cost, making it suitable for large-scale data processing.



## 9. `getsubW()`
**Description**: Constructs sub-matrices for the wavelet transformation at each level. This function is used internally by WavPackMat().

### Example
The function getsubW() is called within WavPackMat() to build sub-matrices as part of the overall wavelet matrix construction process.

**Explanation**: This function iteratively applies the H and G matrices to create sub-matrices for each decomposition level, essential for building the wavelet matrix that is used for signal decomposition.


## 10. `getHGmat()`
**Description**: Constructs sub-matrices for the wavelet transformation at each level. This function is used internally by WavPackMat().

### Example
getHGmat() is used by getsubW() to build H and G matrices for each level of decomposition during wavelet matrix construction.

**Explanation**: getHGmat() creates H and G matrices that are critical for constructing wavelet transformations with circular boundary conditions. These matrices ensure that the input signal is properly processed even when indices wrap around.






