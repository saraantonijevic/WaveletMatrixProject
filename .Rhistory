lambda <- sqrt(2 * log(N)) * sigmahat
# Apply soft thresholding
swt <- sign(sw) * pmax(abs(sw) - lambda, 0)
# Convert and display the thresholded wavelet coefficients as an image
swt_img <- as.cimg(matrix(swt, nrow = 1, ncol = swt_length))
plot(swt_img, main = "Thresholded Wavelet Coefficients Image Representation")
# Plot the thresholded coefficients
ggplot(data.frame(index = 1:N, swt = swt), aes(x = index, y = swt)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Thresholded Wavelet Coefficients")
# (vii) Return the signal to the time domain using the inverse transformation
a <- as.vector(t(WP) %*% swt)
# (viii) Plot the denoised signal and the noisy signal for comparison
ggplot(data.frame(t = t, signoi = signoi, a = a), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = a), color = "black", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Denoised Signal")
# (iii) Plot the noisy signal
ggplot(data.frame(t = t, signoi = signoi, sig = sig), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = sig), color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Noisy Bumps Signal")
# Plot the wavelet coefficients
ggplot(data.frame(index = 1:N, sw = sw), aes(x = index, y = sw)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Wavelet Coefficients")
# Plot the thresholded coefficients
ggplot(data.frame(index = 1:N, swt = swt), aes(x = index, y = swt)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Thresholded Wavelet Coefficients")
#' Demo for Wavelet Denoising using the WaveletMatrixProject package
#'
#' This demo showcases how to denoise a synthetic "bumps" signal using a wavelet
#' packet transformation matrix constructed by WavPackMat.
#' Run this demo using: demo("wavelet_denoising", package = "WaveletMatrixProject")
# Load necessary libraries
library(Matrix)
library(ggplot2)
library(imager)
library(WaveletMatrixProject)
# (i) Generate the "bumps" signal
N <- 1024
t <- seq(0, 1, length.out = N)
pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
wth <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
sig <- numeric(N)
for (j in 1:length(pos)) {
sig <- sig + hgt[j] / (1 + abs((t - pos[j]) / wth[j]))^4
}
# Standardize the signal for a fixed SNR
SNR <- 7
sig <- sig * sqrt(SNR) / sd(sig)
# Convert and display the original signal as an image
sig_img <- as.cimg(matrix(sig, nrow = 1, ncol = N))
plot(sig_img, main = "Original Signal Image Representation")
# Plot the original signal
ggplot(data.frame(t = t, sig = sig), aes(x = t, y = sig)) +
geom_line(color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Original Bumps Signal")
# (ii) Add noise to the signal
set.seed(1)
signoi <- sig + 1/sqrt(SNR) * rnorm(N)
# Convert and display the noisy signal as an image
signoi_img <- as.cimg(matrix(signoi, nrow = 1, ncol = swt_length))
# (ii) Add noise to the signal
set.seed(1)
signoi <- sig + 1/sqrt(SNR) * rnorm(N)
# Convert and display the noisy signal as an image
plot(signoi_img, main = "Noisy Signal Image Representation")
sw <- as.vector(WP %*% signoi)
WP <- WavPackMat(filt, N, k0 = 6)
# (iv) Create the wavelet transformation matrix using WavPackMat
filt <- c(-0.07576571478934, -0.02963552764595,
0.49761866763246, 0.80373875180522,
0.29785779560554, -0.09921954357694,
-0.01260396726226, 0.03222310060407)
WP <- WavPackMat(filt, N, k0 = 6)
# (v) Transform the signal using the wavelet packet matrix
sw <- as.vector(WP %*% signoi)
#' Demo for Wavelet Denoising using the WaveletMatrixProject package
#'
#' This demo showcases how to denoise a synthetic "bumps" signal using a wavelet
#' packet transformation matrix constructed by WavPackMat.
#' Run this demo using: demo("wavelet_denoising", package = "WaveletMatrixProject")
# Load necessary libraries
library(Matrix)
library(ggplot2)
library(imager)
library(WaveletMatrixProject)
# (i) Generate the "bumps" signal
N <- 1024
t <- seq(0, 1, length.out = N)
pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
wth <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
sig <- numeric(N)
for (j in 1:length(pos)) {
sig <- sig + hgt[j] / (1 + abs((t - pos[j]) / wth[j]))^4
}
# Standardize the signal for a fixed SNR
SNR <- 7
sig <- sig * sqrt(SNR) / sd(sig)
# Plot the original signal
ggplot(data.frame(t = t, sig = sig), aes(x = t, y = sig)) +
geom_line(color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Original Bumps Signal")
# (ii) Add noise to the signal
set.seed(1)
signoi <- sig + 1/sqrt(SNR) * rnorm(N)
# (iii) Plot the noisy signal
ggplot(data.frame(t = t, signoi = signoi, sig = sig), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = sig), color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Noisy Bumps Signal")
# (iv) Create the wavelet transformation matrix using WavPackMat
filt <- c(-0.07576571478934, -0.02963552764595,
0.49761866763246, 0.80373875180522,
0.29785779560554, -0.09921954357694,
-0.01260396726226, 0.03222310060407)
WP <- WavPackMat(filt, N, k0 = 6)
# (v) Transform the signal using the wavelet packet matrix
sw <- as.vector(WP %*% signoi)
swt_length <- length(swt)
# (v) Transform the signal using the wavelet packet matrix
sw <- as.vector(WP %*% signoi)
# Plot the wavelet coefficients
ggplot(data.frame(index = 1:N, sw = sw), aes(x = index, y = sw)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Wavelet Coefficients")
# (vi) Threshold the small coefficients
finest <- sw[(N/2+1):N]
sigmahat <- sd(finest)
lambda <- sqrt(2 * log(N)) * sigmahat
# Apply soft thresholding
swt <- sign(sw) * pmax(abs(sw) - lambda, 0)
swt_length <- length(swt)
# Convert and display the thresholded wavelet coefficients as an image
swt_img <- as.cimg(matrix(swt, nrow = 1, ncol = swt_length))
plot(swt_img, main = "Thresholded Wavelet Coefficients Image Representation")
# Plot the thresholded coefficients
ggplot(data.frame(index = 1:N, swt = swt), aes(x = index, y = swt)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Thresholded Wavelet Coefficients")
# (vii) Return the signal to the time domain using the inverse transformation
a <- as.vector(t(WP) %*% swt)
# (viii) Plot the denoised signal and the noisy signal for comparison
ggplot(data.frame(t = t, signoi = signoi, a = a), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = a), color = "black", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Denoised Signal")
#' Demo for Wavelet Denoising using the WaveletMatrixProject package
#'
#' This demo showcases how to denoise a synthetic "bumps" signal using a wavelet
#' packet transformation matrix constructed by WavPackMat.
#' Run this demo using: demo("wavelet_denoising", package = "WaveletMatrixProject")
# Load necessary libraries
library(WaveletMatrixProject)
# (i) Generate the "bumps" signal
N <- 1024
t <- seq(0, 1, length.out = N)
pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
wth <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
sig <- numeric(N)
for (j in 1:length(pos)) {
sig <- sig + hgt[j] / (1 + abs((t - pos[j]) / wth[j]))^4
}
# Standardize the signal for a fixed SNR
SNR <- 7
sig <- sig * sqrt(SNR) / sd(sig)
# Plot the original signal
ggplot(data.frame(t = t, sig = sig), aes(x = t, y = sig)) +
geom_line(color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Original Bumps Signal")
#' Construct Highly Optimized Orthogonal Wavelet Transformation Matrix
#'
#' This function creates an optimized wavelet transformation matrix for high-quality filter coefficients
#' and sparse matrix operations.
#'
#' @param h Numeric vector representing the low-pass filter.
#' @param N Integer specifying the size of the matrix. Must be a power of 2.
#' @param k0 Integer specifying the depth of the wavelet transformation. Should be between 1 and log2(N).
#' @param shift Integer for shifts in the wavelet transformation (default is 2).
#' @return A sparse matrix representing the wavelet packet transformation.
#' @export
#' @importFrom Matrix rBind
#' @import ggplot2
#' @import imager
#' @import pracma
WavPackMat <- function(h, N, k0, shift = 2) {
J <- log2(N)
if (J != floor(J)) {
stop("N has to be a power of 2.")
}
# Make QM filter G
# Make QM filter G
h <- as.vector(h)
g <- rev(Conj(h) * (-1)^(1:length(h)))
h <- c(h, rep(0, N - length(h)))
g <- c(g, rep(0, N - length(g)))
WP <- matrix(nrow = 0, ncol = N)
for (k in 1:k0) {
subW <- getsubW(k, h, g, J, N)
WP <- rbind(WP, subW)
}
WP <- sqrt(1/k0) * WP
return(WP)
}
getsubW <- function(jstep, h, g, J, N) {
subW <- diag(2^(J-jstep))
for (k in jstep:1) {
hgmat <- getHGmat(k, h, g, J, N)
subW <- rbind(subW %*% hgmat$hmat, subW %*% hgmat$gmat)
}
return(subW)
}
getHGmat <- function(k, h, g, J, N) {
ubJk <- 2^(J-k)
ubJk1 <- 2^(J-k+1)
shift <- 2
hmat <- matrix(0, nrow = ubJk1, ncol = ubJk)
gmat <- matrix(0, nrow = ubJk1, ncol = ubJk)
for (jj in 1:ubJk) {
for (ii in 1:ubJk1) {
modulus <- (N + ii - 2 * jj + shift) %% ubJk1
modulus <- modulus + (modulus == 0) * ubJk1
hmat[ii, jj] <- h[modulus]
gmat[ii, jj] <- g[modulus]
}
}
return(list(hmat = t(hmat), gmat = t(gmat)))
}
#' Demo for Wavelet Denoising using the WaveletMatrixProject package
#'
#' This demo showcases how to denoise a synthetic "bumps" signal using a wavelet
#' packet transformation matrix constructed by WavPackMat.
#' Run this demo using: demo("wavelet_denoising", package = "WaveletMatrixProject")
# Load necessary libraries
library(WaveletMatrixProject)
# (i) Generate the "bumps" signal
N <- 1024
t <- seq(0, 1, length.out = N)
pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
wth <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
sig <- numeric(N)
for (j in 1:length(pos)) {
sig <- sig + hgt[j] / (1 + abs((t - pos[j]) / wth[j]))^4
}
# Standardize the signal for a fixed SNR
SNR <- 7
sig <- sig * sqrt(SNR) / sd(sig)
# Plot the original signal
ggplot(data.frame(t = t, sig = sig), aes(x = t, y = sig)) +
geom_line(color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Original Bumps Signal")
getwd()
#' Demo for Wavelet Denoising using the WaveletMatrixProject package
#'
#' This demo showcases how to denoise a synthetic "bumps" signal using a wavelet
#' packet transformation matrix constructed by WavPackMat.
#' Run this demo using: demo("wavelet_denoising", package = "WaveletMatrixProject")
# Load necessary libraries
library(WaveletMatrixProject)
source("C:/Users/saraa/Desktop/WaveletMatrixProject/demo/load_demo_libraries.R")
# (i) Generate the "bumps" signal
N <- 1024
t <- seq(0, 1, length.out = N)
pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
wth <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
sig <- numeric(N)
for (j in 1:length(pos)) {
sig <- sig + hgt[j] / (1 + abs((t - pos[j]) / wth[j]))^4
}
# Standardize the signal for a fixed SNR
SNR <- 7
sig <- sig * sqrt(SNR) / sd(sig)
# Plot the original signal
ggplot(data.frame(t = t, sig = sig), aes(x = t, y = sig)) +
geom_line(color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Original Bumps Signal")
# (ii) Add noise to the signal
set.seed(1)
signoi <- sig + 1/sqrt(SNR) * rnorm(N)
# (iii) Plot the noisy signal
ggplot(data.frame(t = t, signoi = signoi, sig = sig), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = sig), color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Noisy Bumps Signal")
# (iv) Create the wavelet transformation matrix using WavPackMat
filt <- c(-0.07576571478934, -0.02963552764595,
0.49761866763246, 0.80373875180522,
0.29785779560554, -0.09921954357694,
-0.01260396726226, 0.03222310060407)
WP <- WavPackMat(filt, N, k0 = 6)
# (v) Transform the signal using the wavelet packet matrix
sw <- as.vector(WP %*% signoi)
# Plot the wavelet coefficients
ggplot(data.frame(index = 1:N, sw = sw), aes(x = index, y = sw)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Wavelet Coefficients")
# (vi) Threshold the small coefficients
finest <- sw[(N/2+1):N]
sigmahat <- sd(finest)
lambda <- sqrt(2 * log(N)) * sigmahat
# Apply soft thresholding
swt <- sign(sw) * pmax(abs(sw) - lambda, 0)
swt_length <- length(swt)
# Convert and display the thresholded wavelet coefficients as an image
swt_img <- as.cimg(matrix(swt, nrow = 1, ncol = swt_length))
plot(swt_img, main = "Thresholded Wavelet Coefficients Image Representation")
# Plot the thresholded coefficients
ggplot(data.frame(index = 1:N, swt = swt), aes(x = index, y = swt)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Thresholded Wavelet Coefficients")
# (vii) Return the signal to the time domain using the inverse transformation
a <- as.vector(t(WP) %*% swt)
# (viii) Plot the denoised signal and the noisy signal for comparison
ggplot(data.frame(t = t, signoi = signoi, a = a), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = a), color = "black", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Denoised Signal")
# Plot the original signal
ggplot(data.frame(t = t, sig = sig), aes(x = t, y = sig)) +
geom_line(color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Original Bumps Signal")
# (iii) Plot the noisy signal
ggplot(data.frame(t = t, signoi = signoi, sig = sig), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = sig), color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Noisy Bumps Signal")
# Plot the wavelet coefficients
ggplot(data.frame(index = 1:N, sw = sw), aes(x = index, y = sw)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Wavelet Coefficients")
# Plot the thresholded coefficients
ggplot(data.frame(index = 1:N, swt = swt), aes(x = index, y = swt)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Thresholded Wavelet Coefficients")
#' Demo for Wavelet Denoising using the WaveletMatrixProject package
#'
#' This demo showcases how to denoise a synthetic "bumps" signal using a wavelet
#' packet transformation matrix constructed by WavPackMat.
#' Run this demo using: demo("wavelet_denoising", package = "WaveletMatrixProject")
# Load necessary libraries
library(WaveletMatrixProject)
source("C:/Users/saraa/Desktop/WaveletMatrixProject/demo/load_demo_libraries.R")
# (i) Generate the "bumps" signal
N <- 1024
t <- seq(0, 1, length.out = N)
pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
wth <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
sig <- numeric(N)
for (j in 1:length(pos)) {
sig <- sig + hgt[j] / (1 + abs((t - pos[j]) / wth[j]))^4
}
# Standardize the signal for a fixed SNR
SNR <- 7
sig <- sig * sqrt(SNR) / sd(sig)
# Plot the original signal
ggplot(data.frame(t = t, sig = sig), aes(x = t, y = sig)) +
geom_line(color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Original Bumps Signal")
# (ii) Add noise to the signal
set.seed(1)
signoi <- sig + 1/sqrt(SNR) * rnorm(N)
# (iii) Plot the noisy signal
ggplot(data.frame(t = t, signoi = signoi, sig = sig), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = sig), color = "green", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Noisy Bumps Signal")
# (iv) Create the wavelet transformation matrix using WavPackMat
filt <- c(-0.07576571478934, -0.02963552764595,
0.49761866763246, 0.80373875180522,
0.29785779560554, -0.09921954357694,
-0.01260396726226, 0.03222310060407)
WP <- WavPackMat(filt, N, k0 = 6)
# (v) Transform the signal using the wavelet packet matrix
sw <- as.vector(WP %*% signoi)
# Plot the wavelet coefficients
ggplot(data.frame(index = 1:N, sw = sw), aes(x = index, y = sw)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Wavelet Coefficients")
# (vi) Threshold the small coefficients
finest <- sw[(N/2+1):N]
sigmahat <- sd(finest)
lambda <- sqrt(2 * log(N)) * sigmahat
# Apply soft thresholding
swt <- sign(sw) * pmax(abs(sw) - lambda, 0)
swt_length <- length(swt)
# Convert and display the thresholded wavelet coefficients as an image
swt_img <- as.cimg(matrix(swt, nrow = 1, ncol = swt_length))
plot(swt_img, main = "Thresholded Wavelet Coefficients Image Representation")
# Plot the thresholded coefficients
ggplot(data.frame(index = 1:N, swt = swt), aes(x = index, y = swt)) +
geom_line(size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Thresholded Wavelet Coefficients")
# (vii) Return the signal to the time domain using the inverse transformation
a <- as.vector(t(WP) %*% swt)
# (viii) Plot the denoised signal and the noisy signal for comparison
ggplot(data.frame(t = t, signoi = signoi, a = a), aes(x = t)) +
geom_point(aes(y = signoi), color = "red", size = 2) +
geom_line(aes(y = a), color = "black", size = 1) +
theme_minimal(base_size = 16) +
ggtitle("Denoised Signal")
# Load necessary functions and data from the package
library(WaveletMatrixProject)
source("C:/Users/saraa/Desktop/WaveletMatrixProject/demo/load_demo_libraries.R")
cat("Demo6c: Lenna 2d scale-mixing forth and back\n")
# Define Symmlet 4 wavelet filter from wavelets package
h <- c(-0.075765714789341, -0.029635527645954, 0.497618667632458,
0.803738751805216, 0.297857795605542, -0.099219543576935,
-0.012603967262261, 0.032223100604071)
# Load the Lena dataset (assuming it is available as a grayscale matrix)
data("lena")
# Transform lena data to match MATLAB's transformation of image data
A_full <- 255 - t(lena)
# Extract the central 256x256 portion for transformation
center_start <- (512 - 256) / 2 + 1
center_end <- center_start + 255
A <- A_full[center_start:center_end, center_start:center_end]
# Apply padding to the 256x256 submatrix as per MATLAB code
A[, 1:4] <- 255
A[, (ncol(A)-3):ncol(A)] <- 255
A[1:4, ] <- 255
A[(nrow(A)-3):nrow(A), ] <- 255
# Display the padded and transformed 256x256 Lena image using imager
display(as.cimg(A), main = "Padded and Transformed Lena Image (256x256)")
# Plot using base R
par(mfrow = c(2, 2))
image(A, col = gray.colors(256), main = "Padded and Transformed Lena Image (256x256)", useRaster = TRUE)
# Create wavelet matrix using WavPackMat with 256x256 size
N <- 256
k0 <- 2
W <- WavPackMat(h, N, k0)
# Apply the wavelet transformation: B = W * A * W'
B <- W %*% A %*% t(W)
# Display the transformed image using imager
display(as.cimg(B), main = "Transformed Lena Image (B)", rescale = FALSE)
# Plot using base R
image(B, col = gray.colors(256), main = "Transformed Lena Image (B)", zlim = c(0, 20), useRaster = TRUE)
# Inverse transformation: C = W' * B * W
C <- t(W) %*% B %*% W
display(as.cimg(C), main = "Inverse Transformed Image (C)")
# Plot using base R
image(C, col = gray.colors(256), main = "Inverse Transformed Image (C)", useRaster = TRUE)
# Difference image: D = A - C
D <- A - C
display(as.cimg(D), main = "Difference Image (D)", rescale = FALSE)
# Check the range of values in D
cat("Min of D:", min(D), "\n")
cat("Max of D:", max(D), "\n")
# Plot D with an adjusted zlim range
image(D, col = gray.colors(256), main = "Difference Image (D)", zlim = range(D), useRaster = TRUE)
# Scale D for better visualization
D_scaled <- D * 1000
# Checking the range of D_scaled
cat("Min of D_scaled:", min(D_scaled), "\n")
cat("Max of D_scaled:", max(D_scaled), "\n")
# Display using base R
image(D_scaled, col = gray.colors(256), main = "Scaled Difference Image (D)", useRaster = TRUE)
# Normalize D_scaled for imager display
D_scaled_normalized <- (D_scaled - min(D_scaled)) / (max(D_scaled) - min(D_scaled))
display(as.cimg(D_scaled_normalized), main = "Scaled and Normalized Difference Image (D)")
# Debugging Outputs
cat("Mean of A:", mean(A), "\n")
cat("Mean of B:", mean(B), "\n")
cat("Mean of C:", mean(C), "\n")
cat("Mean of D:", mean(D), "\n")
install.packages("devtools")
library(devtools)
devtools::document()
devtools::check()
devtools::document()
devtools::check()
# Install usethis if not already installed
install.packages("usethis")
# Create a README.md file
usethis::use_readme_md()
install.packages("usethis")
devtools::document()
devtools::check()
getwd()
